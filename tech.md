# Техническая документация Neural Quiz Party

## 1. Стек технологий
- **Core:** React 19, TypeScript.
- **Стилизация:** Tailwind CSS.
- **AI Engine:** Google Gemini API (`gemini-2.5-flash`) через SDK `@google/genai`.
- **State Management:** React `useState` + `useRef` (для решения проблем с замыканиями в таймерах и слушателях событий).
- **Networking (Локальный):** `BroadcastChannel API`. Позволяет обмениваться сообщениями между разными контекстами просмотра (вкладками, окнами, фреймами) одного и того же источника (Origin).

## 2. Архитектура приложения
Приложение является изоморфным: один и тот же билд содержит логику и для **Хоста** (Сервер/Дисплей), и для **Клиента** (Контроллер). Режим выбирается при старте в `App.tsx`.

### Хост (`HostScreen.tsx`)
Является "Источником правды" (Single Source of Truth).
- Хранит полное состояние игры (`GameState`).
- Управляет таймерами.
- Генерирует вопросы через API.
- Рассылает обновления состояния (`STATE_UPDATE`) всем клиентам.
- Обрабатывает входящие действия игроков (`VOTE_CATEGORY`, `SUBMIT_ANSWER`).

### Клиент (`ClientScreen.tsx`)
Является "Тонким клиентом".
- Не содержит игровой логики.
- Отображает интерфейс в зависимости от фазы, полученной от Хоста.
- Отправляет действия пользователя на Хост.
- Периодически опрашивает Хост (`REQUEST_STATE`) для синхронизации при потере пакетов.

## 3. Логика генерации контента (`geminiService.ts`)

### Генерация вопросов
- Используется модель `gemini-2.5-flash`.
- **JSON Schema:** Ответ от модели строго типизирован через `responseSchema` и `responseMimeType: "application/json"`.
- **Промпт:**
  - Динамически формируется в зависимости от темы.
  - Содержит требование избегать клише (`distinct and unique`).
  - Включает поле `explanation` для генерации интересных фактов.

### Алгоритм уникальности (Deduplication)
Поскольку API не имеет памяти контекста между запросами:
1. Хост поддерживает `useRef<Set<string>> questionHistoryRef`.
2. При получении пачки вопросов от AI, они нормализуются (lowercase + trim).
3. Дубликаты отбрасываются.
4. Если после фильтрации вопросов недостаточно, запускается цикл повторных запросов (до 3-х попыток), пока пул вопросов не заполнится.

## 4. Сетевой протокол
Обмен сообщениями происходит через JSON-объекты типа `NetworkMessage`.

| Тип сообщения | Отправитель | Описание |
|---|---|---|
| `JOIN` | Клиент | Игрок сообщает о входе (имя, аватар). |
| `STATE_UPDATE` | Хост | Полный слепок состояния игры (рассылается всем). |
| `VOTE_CATEGORY` | Клиент | Голос за тему раунда. |
| `SUBMIT_ANSWER` | Клиент | Выбранный индекс ответа. |
| `REQUEST_STATE` | Клиент | Принудительный запрос актуального состояния (при реконнекте). |
| `REQUEST_NEXT_STEP` | Клиент | Сигнал "Продолжить" (переход от результатов к следующему вопросу). |

## 5. Машина состояний (Game Phase)
1. **LOBBY:** Ожидание подключения игроков.
2. **CATEGORY_SELECTION:** Отображение диаграммы голосования за тему.
3. **LEVEL_INTRO:** (Скрытая фаза загрузки) Генерация вопросов.
4. **QUESTION:** Хост показывает вопрос, Клиенты — кнопки. Таймер 8с.
5. **ANSWERS_REVEAL:** Показ правильного ответа, фактов и цветов результатов. Ожидание ручного перехода.
6. **LEVEL_COMPLETE:** Таблица лидеров за уровень.
7. **GAME_OVER:** Финальный экран победителя.

## 6. Установка и запуск (Dev)
Проект не требует бэкенда (Node.js/Python). Весь код выполняется в браузере.
Для работы требуется переменная окружения `process.env.API_KEY` с ключом от Google Gemini.
